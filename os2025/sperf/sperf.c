#include <linux/limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#include <fcntl.h>

// Feel free to change the data structures generated by AI.

#define MAX_SYSCALLS 1024
#define OUTPUT_INTERVAL 100000
#define TOP_N 5
#define SEPARATOR_SIZE 80

typedef struct {
    char name[64];
    double time;
} syscall_stat;

typedef struct {
    syscall_stat stats[MAX_SYSCALLS];
    int count;
    double total_time;
} syscall_stats;

syscall_stats* systemcall = NULL;

char* find_executable(const char* cmd) {
    if (strchr(cmd, '/') != NULL) {
        return strdup(cmd);
    }

    char* path = getenv("PATH");
    if (path == NULL) {
        return NULL;
    }

    char* path_copy = strdup(path);
    char* dir = strtok(path_copy, ":");
    while (dir != NULL) {
        char* full_path = malloc(PATH_MAX * sizeof(char));
        sprintf(full_path, "%s/%s", dir, cmd);
        
        if (access(full_path, X_OK) == 0) {
            free(path_copy);
            return strdup(full_path);
        }

        dir = strtok(NULL, ":"); 
    }

    free(path_copy);
    return NULL;
}

void add_syscall(syscall_stats *stats, const char *name, double time) {
    // if (stats == NULL) {
    //     stats = malloc(sizeof(syscall_stats));
    //     stats->count = 0;
    //     stats->total_time = 0;    
    // }
    
    for (int i = 0; i < stats->count; i++) {
        if (strcmp(stats->stats[i].name, name) == 0) {
            stats->stats[i].time += time;
            stats->total_time += time;
            return;
        }
    }
    
    if (stats->count < MAX_SYSCALLS) {
        strcpy(stats->stats[stats->count].name, name);
        stats->stats[stats->count].time = time;
        stats->total_time += time;
        stats->count++;
        return;
    }
}

int parse_strace_line(char *line, char *syscall_name, double *time) {
    // printf("%s\n", line);
    char* line_copy = strdup(line);
    char* time_start = strrchr(line_copy, '<');
    char* time_end = strrchr(line_copy, '>');
    
    if (time_start && time_end && time_start < time_end) {
        *time_end = '\0';
        *time = atof(time_start + 1);
        
        char* paren = strchr(line_copy, '(');
        if (paren) {
            *paren = '\0';
            strcpy(syscall_name, line_copy);
            add_syscall(systemcall, syscall_name, *time);
            return 1;
        }
    }
    return 0;
}

int compare_syscalls(const void* a, const void* b) {
    const syscall_stat* sa = (const syscall_stat*)a;
    const syscall_stat* sb = (const syscall_stat*)b;
    return sb->time == sa->time ? 0 : (sb->time > sa->time ? 1 : -1);
}

void print_top_syscalls(syscall_stats *stats, int n) {
    if (stats->total_time == 0) return;

    syscall_stat temp[MAX_SYSCALLS];
    int count = 0;
    for (int i = 0; i < stats->count; i++) {
        if (stats->stats[i].time > 0) {
            temp[count] = stats->stats[i];
            count++;
        }
    }

    if (count == 0) return;

    qsort(temp, count, sizeof(syscall_stat), compare_syscalls);

    for (int i = 0; i < n; i++) {
        int ratio = (int)((temp[i].time * 100) / stats->total_time);
        printf("%s (%d%%)\n", temp[i].name, ratio);
    }

    for (int i = 0; i < SEPARATOR_SIZE; i++) {
        putchar(0);
    }
    fflush(stdout);
}

int main(int argc, char *argv[], char *envp[]) {
    systemcall = malloc(sizeof(syscall_stats));
    if (systemcall == NULL) {
        perror("malloc");
        return 1;
    }
    memset(systemcall, 0, sizeof(syscall_stats));
    
    if (argc < 2) {
        fprintf(stderr, "Usage: sperf COMMAND [ARG]...\n");
        return 1;
    }

    char* cmd = find_executable(argv[1]);
    if (cmd == NULL) {
        fprintf(stderr, "Command not found: %s\n", argv[1]);
        return 1;
    }

    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    int flags = fcntl(pipefd[0], F_GETFL);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        return 1;
    }
    if (fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        return 1;
    }

    pid_t pid = fork();
    if (pid < 0) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        close(pipefd[0]);
        dup2(pipefd[1], STDERR_FILENO);
        close(pipefd[1]);
        
	    char** exec_args = malloc((argc+2) * sizeof(char*));
        exec_args[0] = "strace";
        exec_args[1] = "-T";
        for (int i = 1; i < argc; i++) {
            exec_args[i+1] = argv[i];
        }
        exec_args[argc+1] = NULL;
        
        // char* exec_envp[] = {"PATH=/bin", NULL, };
        // freopen("/dev/null", "w", stdout);
        execve("strace",          exec_args, envp);
        execve("/bin/strace",     exec_args, envp);
        execve("/usr/bin/strace", exec_args, envp);
        
        perror("execve");
        exit(1);
    }

    free(cmd);
    close(pipefd[1]);

    // FILE* strace_output = fdopen(pipefd[0], "r");
    // if (strace_output == NULL) {
    //     perror("fdopen");
    //     return 1;
    // }

    struct timeval last_output_time;
    gettimeofday(&last_output_time, NULL);

    // freopen("/dev/tty", "w", stdout);
    int status;
    char line[1024];
    int linetop = 0;
    while (1) {
        // puts("while");
        char buffer[1024] = {};
        int bufcnt = 0;
        if ((bufcnt = read(pipefd[0], buffer, 1023))) {
            for (int i = 0; i < bufcnt; i++) {
                if (buffer[i] == '\n') {
                    char syscall_name[64];
                    double time;
                    parse_strace_line(line, syscall_name, &time);
                    linetop = 0;
                    memset(line, 0x00, sizeof(line));
                }
                else {
                    line[linetop++] = buffer[i];
                }
            }
        }
        struct timeval now;
        gettimeofday(&now, NULL);
        
        long long interval = (now.tv_sec - last_output_time.tv_sec) * 1000000 + (now.tv_usec - last_output_time.tv_usec);
        if (interval >= OUTPUT_INTERVAL) {
            int n = (systemcall->count < TOP_N) ? systemcall->count : TOP_N;
            printf("Time: %.1fs\n", interval/1000000.0);
            print_top_syscalls(systemcall, n);
            last_output_time = now;
        }
        // puts("while2");
        pid_t result = waitpid(pid, &status, WNOHANG);
        if (result == -1) {
            perror("waitpid");
            break;
        }
        else if (result > 0) {
            break;
        }
    }

    
    // char line[1024];
    // while (fgets(line, sizeof(line), strace_output)) {
    //     char syscall_name[64];
    //     double time;
    //     parse_strace_line(line, syscall_name, &time);
    // }

    close(pipefd[1]);

    int n = (systemcall->count < TOP_N) ? systemcall->count : TOP_N;
    printf("Final time: %.1fs\n", systemcall->total_time);
    print_top_syscalls(systemcall, n);

    return 0;
}
